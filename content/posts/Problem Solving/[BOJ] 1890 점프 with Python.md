---
author: ["Jxun-h"]
title: "[BOJ] 1890 점프 with Python"
date: "2022-08-09 17:33:00"
description: ""
summary: ""
tags: ["자료구조", "PS", "DP", "백준", "BOJ"]
categories: ["Algorithm"]
series: ["BOJ"]
ShowToc: false
---

<br>

## 📌 <a href="https://www.acmicpc.net/problem/1890" target="_blank">BOJ 1890 점프</a>

<br>

### 💡 조건

1.  N×N 게임판에 수가 적혀져 있다.  
    N (4 ≤ N ≤ 100)

2.  이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.  
    각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다.  
    칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.

3.  반드시 오른쪽이나 아래쪽으로만 이동해야 한다.  
    0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다.

4.  한 번 점프를 할 때, 방향을 바꾸면 안 된다.  
    즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.

5.  가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 문제.

6.  **DP** 유형의 문제

<br>

### 🔖 예제 및 실행결과

#### 예제

```py
4
2 3 3 1
1 2 1 3
1 2 3 1
3 1 1 0
```

#### 실행결과

```py
3
```

<br>

### ⌨️ 문제 풀이

1.  경로의 개수를 구하는 문제이다. 이 문제는 하나하나 경로를 살펴보기 위해서 dfs를 사용할 경우, 시간복잡도가 매우 크게 나온다.

2.  다이나믹프로그래밍 알고리즘을 이용하여 문제를 해결해야하는데, 우리는 문제에서 아래와 같은 조건에 주목을 해서 풀면 쉽게 생각해볼 수 있는 문제이다.  
    **칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.**  
    **반드시 오른쪽이나 아래쪽으로만 이동해야 한다.**  
    **0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다.**

3.  (0, 0)에서 시작해 (n - 1, n - 1) 까지 가는 경우의 수를 DP 리스트에 저장해나가면서 반복문을 통해 문제를 해결한다면,  
    시간복잡도는 약 O(N * N) 이 나온다. 최악의 경우를 고려하더라도 최대 약 10,000 정도밖에 안걸린다.  
    DP 리스트는 n * n 크기의 리스트로 만들고, (0, 0)은 1로 초기화한다.

4.  2중 for 문을 사용하여, 만약 현재 위치한 곳이 (n - 1, n - 1) 이라면 dp[i][j]를 출력하면 된다.

5.  (4)번의 경우가 아니라면, (i, j)에 해당하는 arr의 값을 cur 라는 변수에 저장한다.  
    현재 위치인 (i, j) 에서 우측으로 cur 만큼 이동을 할 수 있다면, dp[i][j + cur]에 dp[i][j]를 더해준다.  
    현재 위치인 (i, j) 에서 하단으로 cur 만큼 이동을 할 수 있다면, dp[i + cur][j]에 dp[i][j]를 더해준다.

<br>

### 🖥 소스 코드

```py
from sys import stdin

n = int(stdin.readline())
arr = []
for _ in range(n):
    arr.append(list(map(int, stdin.readline().split())))

dp = [[0] * n for _ in range(n)]
dp[0][0] = 1


for i in range(n):
    for j in range(n):
        if i == n - 1 and j == n - 1:
            print(dp[i][j])
            break

        cur = arr[i][j]

        if j + cur < n:
            dp[i][j + cur] += dp[i][j]

        if i + cur < n:
            dp[i + cur][j] += dp[i][j]
```